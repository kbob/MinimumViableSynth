#!/usr/bin/env python3

from collections import defaultdict
import itertools
import PIL.Image
import pprint

# Simple Run-Length Encoding
# 
# First byte determines run encoding.
#   0 -> single pixel, RGB = next 3 bytes
#   1..127 -> run of 1..127 pixels, RGB = next 3 bytes
#   128..254 -> N = 2nd byte; run of (a - 128) << 8 | N pixels, RGB = next 3
#   255-> N = 2nd byte; run of N pixels, each a different R G B.

im = PIL.Image.open('Color Text Sample.png')
data = im.getdata()
pixels = (pix[:3] for pix in data)
runs = ((len(list(run)), pix) for pix, run in itertools.groupby(pixels))
lenruns = ((l, [run[1] for run in runs])
           for l, runs in itertools.groupby(runs, lambda lp: lp[0]))

def dbg(*args):
    pass

def emit_bytes(lenruns):
    for (count, runs) in lenruns:
        if count == 1 and len(runs) == 1:
            # Single pixel
            dbg('single', count, len(runs))
            yield 0
            dbg('       pix', runs[0])
            yield from runs[0]
        elif count == 1:
            # Run of different pixels
            dbg('mixed ', count, len(runs))
            yield 255
            assert 1 < len(runs) < 256
            yield len(runs)
            for pix in runs:
                yield from pix
        elif count < 128:
            # Short run of solid color
            dbg('short ', count, len(runs))
            assert len(runs) == 1
            yield count
            yield from runs[0]
        elif count <= 127 * 256:
            # Long run of solid color
            dbg('long  ', count, len(runs))
            dbg('      ', runs[0])
            assert len(runs) == 1
            yield count >> 8 | 128
            yield count & 0xFF
            yield from runs[0]
        else:
            # Several long runs of solid color
            dbg('split ', count)
            assert len(runs) == 1
            while count:
                scount = min(count, 127 * 256 - 1)
                dbg('call', runs)
                yield from emit_bytes(((scount, runs),))
                dbg('return')
                count -= scount

# Testing, write bin file
bi = list(emit_bytes(lenruns))
bb = bytes(bi)
# bb = bytes(emit_bytes(lenruns))
with open('foo.bin', 'wb') as out:
   out.write(bb)

def isplit(s, n):
    z = []
    for i, x in enumerate(s):
        z.append(x)
        if i % n == n - 1:
            yield z
            z = []
    if z:
        yield z

preamble = '''
/* Automatically generated by compile.py.  Do not edit. */

#include <stdint.h>
'''.lstrip()

postamble = '};'

with open('foo.h', 'w') as out:
    print(preamble, file=out)
    print('#define IMG_WIDTH  %d' % im.size[0], file=out)
    print('#define IMG_HEIGHT %d' % im.size[1], file=out)
    print(file=out)
    print('uint8_t img_data[] = {', file=out)
    for x in isplit(bi, 12):
        print('    ' + ', '.join('%3d' % i for i in x) + ',', file=out)
    print(postamble, file=out)
